<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polaris: Quantum State Cartography</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            animation: fadeInDown 0.8s ease;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(90deg, #00d4ff, #7b2ff7, #ff00e0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #a0a0ff;
            font-size: 1.1em;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: fadeIn 1s ease;
        }

        .circuit-panel {
            min-height: 200px;
        }

        .bloch-container {
            height: 400px;
            position: relative;
            border-radius: 10px;
            overflow: hidden;
        }

        #blochCanvas {
            width: 100%;
            height: 100%;
        }

        .gate-palette {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .gate {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: grab;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .gate:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .gate:active {
            cursor: grabbing;
        }

        .gate.noise-gate {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .gate.two-qubit {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .circuit-tracks {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            min-height: 150px;
            position: relative;
        }

        .qubit-track {
            height: 60px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px dashed rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            margin-bottom: 10px;
            position: relative;
            display: flex;
            align-items: center;
            padding: 0 10px;
        }

        .qubit-label {
            position: absolute;
            left: -50px;
            font-weight: 600;
            color: #00d4ff;
        }

        .placed-gate {
            position: absolute;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-weight: 600;
            cursor: move;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .placed-gate:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #a0a0ff;
            font-weight: 500;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.6);
        }

        .value-display {
            min-width: 50px;
            text-align: right;
            font-family: 'Courier New', monospace;
            color: #00d4ff;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .metric {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .metric-label {
            color: #a0a0ff;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 1.8em;
            font-weight: 700;
            background: linear-gradient(90deg, #00d4ff, #7b2ff7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-family: 'Courier New', monospace;
        }

        .bell-button, .action-button {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 10px;
        }

        .bell-button:hover, .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(240, 147, 251, 0.4);
        }

        .chsh-panel {
            background: rgba(0, 212, 255, 0.05);
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        .chsh-value {
            font-size: 2.5em;
            text-align: center;
            margin: 20px 0;
            font-weight: 700;
        }

        .chsh-classical {
            color: #ff6b6b;
        }

        .chsh-quantum {
            color: #51cf66;
        }

        .correlation-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .correlation-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .correlation-label {
            color: #a0a0ff;
            font-size: 0.85em;
            margin-bottom: 5px;
        }

        .correlation-value {
            font-size: 1.4em;
            font-weight: 600;
            color: #00d4ff;
            font-family: 'Courier New', monospace;
        }

        .mitigation-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .mitigation-button {
            flex: 1;
            padding: 10px;
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: #00d4ff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mitigation-button:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: translateY(-2px);
        }

        .mitigation-button.active {
            background: rgba(0, 212, 255, 0.3);
            border-color: #00d4ff;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        .timeline-scrubber {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .timeline-label {
            color: #a0a0ff;
            margin-bottom: 8px;
            font-weight: 500;
        }

        #timelineSlider {
            width: 100%;
        }

        .clear-button {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.4);
            color: #ff6b6b;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        .clear-button:hover {
            background: rgba(255, 107, 107, 0.3);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Polaris</h1>
            <p class="subtitle">Quantum State Cartography & Noise Dynamics on the Bloch Sphere</p>
        </header>

        <div class="main-grid">
            <div class="left-section">
                <div class="panel circuit-panel">
                    <h3>Circuit Builder</h3>
                    <div class="gate-palette">
                        <button class="gate" data-gate="H">H</button>
                        <button class="gate" data-gate="X">X</button>
                        <button class="gate" data-gate="Y">Y</button>
                        <button class="gate" data-gate="Z">Z</button>
                        <button class="gate" data-gate="S">S</button>
                        <button class="gate" data-gate="T">T</button>
                        <button class="gate" data-gate="Rx">Rx(π/4)</button>
                        <button class="gate" data-gate="Ry">Ry(π/4)</button>
                        <button class="gate" data-gate="Rz">Rz(π/4)</button>
                        <button class="gate two-qubit" data-gate="CNOT">CNOT</button>
                    </div>
                    <div class="circuit-tracks">
                        <div class="qubit-track" data-qubit="0">
                            <span class="qubit-label">|q₀⟩</span>
                        </div>
                        <div class="qubit-track" data-qubit="1">
                            <span class="qubit-label">|q₁⟩</span>
                        </div>
                    </div>
                    <button class="clear-button" onclick="clearCircuit()">Clear Circuit</button>
                    <div class="timeline-scrubber">
                        <div class="timeline-label">Timeline Position</div>
                        <input type="range" id="timelineSlider" min="0" max="10" value="0" step="1">
                    </div>
                </div>

                <div class="controls-grid">
                    <div class="panel">
                        <h3>Noise Channels</h3>
                        <div class="control-group">
                            <label>Dephasing (p)</label>
                            <div class="slider-container">
                                <input type="range" id="dephasingSlider" min="0" max="1" step="0.01" value="0">
                                <span class="value-display" id="dephasingValue">0.00</span>
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Depolarizing (p)</label>
                            <div class="slider-container">
                                <input type="range" id="depolarizingSlider" min="0" max="1" step="0.01" value="0">
                                <span class="value-display" id="depolarizingValue">0.00</span>
                            </div>
                        </div>
                        <div class="control-group">
                            <label>Amplitude Damping (γ)</label>
                            <div class="slider-container">
                                <input type="range" id="amplitudeSlider" min="0" max="1" step="0.01" value="0">
                                <span class="value-display" id="amplitudeValue">0.00</span>
                            </div>
                        </div>
                    </div>

                    <div class="panel">
                        <h3>Bell State & CHSH</h3>
                        <button class="bell-button" onclick="createBellState()">Create Bell State</button>
                        <div class="chsh-panel" style="margin-top: 15px;">
                            <div class="correlation-label">CHSH Inequality (S)</div>
                            <div class="chsh-value" id="chshValue">0.000</div>
                            <div class="correlation-grid">
                                <div class="correlation-item">
                                    <div class="correlation-label">E(A,B)</div>
                                    <div class="correlation-value" id="eAB">0.00</div>
                                </div>
                                <div class="correlation-item">
                                    <div class="correlation-label">E(A,B')</div>
                                    <div class="correlation-value" id="eABp">0.00</div>
                                </div>
                                <div class="correlation-item">
                                    <div class="correlation-label">E(A',B)</div>
                                    <div class="correlation-value" id="eApB">0.00</div>
                                </div>
                                <div class="correlation-item">
                                    <div class="correlation-label">E(A',B')</div>
                                    <div class="correlation-value" id="eApBp">0.00</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <h3>Error Mitigation</h3>
                    <div class="mitigation-controls">
                        <button class="mitigation-button" id="readoutCalib" onclick="toggleReadoutCalibration()">
                            Readout Calibration
                        </button>
                        <button class="mitigation-button" id="zneButton" onclick="toggleZNE()">
                            Zero-Noise Extrapolation
                        </button>
                    </div>
                    <div class="metrics-grid" style="margin-top: 15px;">
                        <div class="metric">
                            <div class="metric-label">Raw Fidelity</div>
                            <div class="metric-value" id="rawFidelity">1.000</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Mitigated Fidelity</div>
                            <div class="metric-value" id="mitigatedFidelity">1.000</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="right-section">
                <div class="panel">
                    <h3>Bloch Sphere</h3>
                    <div class="bloch-container">
                        <div id="blochCanvas"></div>
                    </div>
                    <div class="metrics-grid">
                        <div class="metric">
                            <div class="metric-label">⟨X⟩</div>
                            <div class="metric-value" id="expectX">0.00</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">⟨Y⟩</div>
                            <div class="metric-value" id="expectY">0.00</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">⟨Z⟩</div>
                            <div class="metric-value" id="expectZ">1.00</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Purity</div>
                            <div class="metric-value" id="purity">1.000</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Complex number operations
        class Complex {
            constructor(real, imag = 0) {
                this.real = real;
                this.imag = imag;
            }

            static add(a, b) {
                return new Complex(a.real + b.real, a.imag + b.imag);
            }

            static multiply(a, b) {
                return new Complex(
                    a.real * b.real - a.imag * b.imag,
                    a.real * b.imag + a.imag * b.real
                );
            }

            static scale(a, scalar) {
                return new Complex(a.real * scalar, a.imag * scalar);
            }

            conjugate() {
                return new Complex(this.real, -this.imag);
            }

            magnitude() {
                return Math.sqrt(this.real * this.real + this.imag * this.imag);
            }
        }

        // Quantum state and operations
        class QuantumState {
            constructor(numQubits = 1) {
                this.numQubits = numQubits;
                this.dim = Math.pow(2, numQubits);
                this.densityMatrix = this.initializeDensityMatrix();
            }

            initializeDensityMatrix() {
                // Initialize to |00...0⟩⟨00...0|
                const rho = Array(this.dim).fill(null).map(() => 
                    Array(this.dim).fill(null).map(() => new Complex(0))
                );
                rho[0][0] = new Complex(1);
                return rho;
            }

            applyUnitary(U, targetQubits) {
                // Apply U ρ U†
                const newRho = this.matrixMultiply(
                    this.matrixMultiply(U, this.densityMatrix),
                    this.conjugateTranspose(U)
                );
                this.densityMatrix = newRho;
            }

            applyKrausOperators(krausOps) {
                // Apply Σ_k E_k ρ E_k†
                const newRho = Array(this.dim).fill(null).map(() => 
                    Array(this.dim).fill(null).map(() => new Complex(0))
                );
                
                for (const E of krausOps) {
                    const term = this.matrixMultiply(
                        this.matrixMultiply(E, this.densityMatrix),
                        this.conjugateTranspose(E)
                    );
                    for (let i = 0; i < this.dim; i++) {
                        for (let j = 0; j < this.dim; j++) {
                            newRho[i][j] = Complex.add(newRho[i][j], term[i][j]);
                        }
                    }
                }
                this.densityMatrix = newRho;
            }

            matrixMultiply(A, B) {
                const rows = A.length;
                const cols = B[0].length;
                const common = B.length;
                const C = Array(rows).fill(null).map(() => 
                    Array(cols).fill(null).map(() => new Complex(0))
                );
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        for (let k = 0; k < common; k++) {
                            C[i][j] = Complex.add(C[i][j], Complex.multiply(A[i][k], B[k][j]));
                        }
                    }
                }
                return C;
            }

            conjugateTranspose(M) {
                const rows = M.length;
                const cols = M[0].length;
                const Mt = Array(cols).fill(null).map(() => 
                    Array(rows).fill(null).map(() => new Complex(0))
                );
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        Mt[j][i] = M[i][j].conjugate();
                    }
                }
                return Mt;
            }

            trace(M) {
                let sum = new Complex(0);
                for (let i = 0; i < M.length; i++) {
                    sum = Complex.add(sum, M[i][i]);
                }
                return sum;
            }

            expectationValue(observable) {
                // Tr(ρ O)
                const product = this.matrixMultiply(this.densityMatrix, observable);
                return this.trace(product).real;
            }

            purity() {
                // Tr(ρ²)
                const rhoSquared = this.matrixMultiply(this.densityMatrix, this.densityMatrix);
                return this.trace(rhoSquared).real;
            }

            getBlochVector() {
                if (this.numQubits !== 1) return [0, 0, 0];
                
                const X = [[new Complex(0), new Complex(1)], 
                          [new Complex(1), new Complex(0)]];
                const Y = [[new Complex(0), new Complex(0, -1)], 
                          [new Complex(0, 1), new Complex(0)]];
                const Z = [[new Complex(1), new Complex(0)], 
                          [new Complex(0), new Complex(-1)]];
                
                return [
                    this.expectationValue(X),
                    this.expectationValue(Y),
                    this.expectationValue(Z)
                ];
            }
        }

        // Gate definitions
        const Gates = {
            I: () => [[new Complex(1), new Complex(0)], 
                     [new Complex(0), new Complex(1)]],
            
            X: () => [[new Complex(0), new Complex(1)], 
                     [new Complex(1), new Complex(0)]],
            
            Y: () => [[new Complex(0), new Complex(0, -1)], 
                     [new Complex(0, 1), new Complex(0)]],
            
            Z: () => [[new Complex(1), new Complex(0)], 
                     [new Complex(0), new Complex(-1)]],
            
            H: () => {
                const s = 1 / Math.sqrt(2);
                return [[new Complex(s), new Complex(s)], 
                       [new Complex(s), new Complex(-s)]];
            },
            
            S: () => [[new Complex(1), new Complex(0)], 
                     [new Complex(0), new Complex(0, 1)]],
            
            T: () => {
                const phase = Math.exp(Math.PI / 4);
                return [[new Complex(1), new Complex(0)], 
                       [new Complex(0), new Complex(Math.cos(Math.PI/4), Math.sin(Math.PI/4))]];
            },
            
            Rx: (theta = Math.PI/4) => {
                const c = Math.cos(theta/2);
                const s = Math.sin(theta/2);
                return [[new Complex(c), new Complex(0, -s)], 
                       [new Complex(0, -s), new Complex(c)]];
            },
            
            Ry: (theta = Math.PI/4) => {
                const c = Math.cos(theta/2);
                const s = Math.sin(theta/2);
                return [[new Complex(c), new Complex(-s)], 
                       [new Complex(s), new Complex(c)]];
            },
            
            Rz: (theta = Math.PI/4) => {
                const c = Math.cos(theta/2);
                const s = Math.sin(theta/2);
                return [[new Complex(c, -s), new Complex(0)], 
                       [new Complex(0), new Complex(c, s)]];
            },
            
            CNOT: () => {
                return [
                    [new Complex(1), new Complex(0), new Complex(0), new Complex(0)],
                    [new Complex(0), new Complex(1), new Complex(0), new Complex(0)],
                    [new Complex(0), new Complex(0), new Complex(0), new Complex(1)],
                    [new Complex(0), new Complex(0), new Complex(1), new Complex(0)]
                ];
            }
        };

        // Noise channel implementations
        class NoiseChannels {
            static dephasing(p) {
                if (p === 0) return [Gates.I()];
                const E0 = [[new Complex(Math.sqrt(1-p)), new Complex(0)], 
                           [new Complex(0), new Complex(Math.sqrt(1-p))]];
                const E1 = [[new Complex(Math.sqrt(p)), new Complex(0)], 
                           [new Complex(0), new Complex(-Math.sqrt(p))]];
                return [E0, E1];
            }

            static depolarizing(p) {
                if (p === 0) return [Gates.I()];
                const factor = Math.sqrt(p/3);
                const E0 = [[new Complex(Math.sqrt(1-p)), new Complex(0)], 
                           [new Complex(0), new Complex(Math.sqrt(1-p))]];
                const E1 = Gates.X().map(row => row.map(c => Complex.scale(c, factor)));
                const E2 = Gates.Y().map(row => row.map(c => Complex.scale(c, factor)));
                const E3 = Gates.Z().map(row => row.map(c => Complex.scale(c, factor)));
                return [E0, E1, E2, E3];
            }

            static amplitudeDamping(gamma) {
                if (gamma === 0) return [Gates.I()];
                const E0 = [[new Complex(1), new Complex(0)], 
                           [new Complex(0), new Complex(Math.sqrt(1-gamma))]];
                const E1 = [[new Complex(0), new Complex(Math.sqrt(gamma))], 
                           [new Complex(0), new Complex(0)]];
                return [E0, E1];
            }
        }

        // Three.js Bloch sphere visualization
        class BlochSphere {
            constructor(containerId) {
                this.container = document.getElementById(containerId);
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(
                    45, 
                    this.container.clientWidth / this.container.clientHeight,
                    0.1, 
                    1000
                );
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.container.appendChild(this.renderer.domElement);
                
                this.camera.position.set(3, 2, 3);
                this.camera.lookAt(0, 0, 0);
                
                this.setupLights();
                this.createSphere();
                this.createAxes();
                this.createStateVector();
                this.trail = [];
                
                this.animate();
            }

            setupLights() {
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
                directionalLight.position.set(5, 5, 5);
                this.scene.add(directionalLight);
            }

            createSphere() {
                // Transparent sphere
                const geometry = new THREE.SphereGeometry(1, 32, 32);
                const material = new THREE.MeshPhysicalMaterial({
                    color: 0x4080ff,
                    transparent: true,
                    opacity: 0.15,
                    roughness: 0.1,
                    metalness: 0.2,
                    clearcoat: 1.0
                });
                this.sphere = new THREE.Mesh(geometry, material);
                this.scene.add(this.sphere);

                // Wireframe
                const wireframe = new THREE.WireframeGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x3060ff, 
                    opacity: 0.2, 
                    transparent: true 
                });
                const lines = new THREE.LineSegments(wireframe, lineMaterial);
                this.scene.add(lines);
            }

            createAxes() {
                const axisLength = 1.3;
                
                // X axis (red)
                const xGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(-axisLength, 0, 0),
                    new THREE.Vector3(axisLength, 0, 0)
                ]);
                const xMaterial = new THREE.LineBasicMaterial({ color: 0xff4080 });
                const xAxis = new THREE.Line(xGeometry, xMaterial);
                this.scene.add(xAxis);

                // Y axis (green)
                const yGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, -axisLength, 0),
                    new THREE.Vector3(0, axisLength, 0)
                ]);
                const yMaterial = new THREE.LineBasicMaterial({ color: 0x40ff80 });
                const yAxis = new THREE.Line(yGeometry, yMaterial);
                this.scene.add(yAxis);

                // Z axis (blue)
                const zGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, -axisLength),
                    new THREE.Vector3(0, 0, axisLength)
                ]);
                const zMaterial = new THREE.LineBasicMaterial({ color: 0x4080ff });
                const zAxis = new THREE.Line(zGeometry, zMaterial);
                this.scene.add(zAxis);

                // Labels
                this.createAxisLabel('X', new THREE.Vector3(axisLength + 0.2, 0, 0), 0xff4080);
                this.createAxisLabel('Y', new THREE.Vector3(0, axisLength + 0.2, 0), 0x40ff80);
                this.createAxisLabel('Z', new THREE.Vector3(0, 0, axisLength + 0.2), 0x4080ff);
                this.createAxisLabel('|0⟩', new THREE.Vector3(0, 0, axisLength + 0.35), 0xffffff);
                this.createAxisLabel('|1⟩', new THREE.Vector3(0, 0, -axisLength - 0.35), 0xffffff);
            }

            createAxisLabel(text, position, color) {
                // Create sprite for text label
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                context.font = '48px Arial';
                context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, 32, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(position);
                sprite.scale.set(0.3, 0.3, 1);
                this.scene.add(sprite);
            }

            createStateVector() {
                // Arrow for state vector
                const arrowGeometry = new THREE.ConeGeometry(0.06, 0.2, 8);
                const arrowMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.3
                });
                this.arrowHead = new THREE.Mesh(arrowGeometry, arrowMaterial);
                this.scene.add(this.arrowHead);

                // Line for state vector
                const lineGeometry = new THREE.BufferGeometry();
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffff00,
                    linewidth: 3
                });
                this.stateLine = new THREE.Line(lineGeometry, lineMaterial);
                this.scene.add(this.stateLine);
            }

            updateStateVector(x, y, z) {
                // Normalize to unit sphere
                const length = Math.sqrt(x*x + y*y + z*z);
                if (length > 0) {
                    x /= length;
                    y /= length;
                    z /= length;
                }

                // Update arrow position and orientation
                this.arrowHead.position.set(x, z, -y); // Convert to Three.js coordinates
                this.arrowHead.lookAt(0, 0, 0);
                this.arrowHead.rotateX(Math.PI/2);

                // Update line
                const points = [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(x * 0.9, z * 0.9, -y * 0.9)
                ];
                this.stateLine.geometry.setFromPoints(points);

                // Add to trail
                this.addTrailPoint(x, z, -y);
            }

            addTrailPoint(x, y, z) {
                const trailGeometry = new THREE.SphereGeometry(0.02, 8, 8);
                const trailMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    opacity: 0.3,
                    transparent: true
                });
                const trailPoint = new THREE.Mesh(trailGeometry, trailMaterial);
                trailPoint.position.set(x, y, z);
                this.scene.add(trailPoint);
                this.trail.push(trailPoint);

                // Keep trail limited
                if (this.trail.length > 50) {
                    const oldPoint = this.trail.shift();
                    this.scene.remove(oldPoint);
                }
            }

            clearTrail() {
                for (const point of this.trail) {
                    this.scene.remove(point);
                }
                this.trail = [];
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Rotate sphere slowly
                this.sphere.rotation.y += 0.002;
                
                this.renderer.render(this.scene, this.camera);
            }

            resize() {
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
        }

        // CHSH calculation
        class CHSHCalculator {
            static calculateCorrelation(rho, A, B) {
                // E(A,B) = Tr(ρ (A ⊗ B))
                const AB = this.tensorProduct(A, B);
                const state = new QuantumState(2);
                state.densityMatrix = rho;
                return state.expectationValue(AB);
            }

            static tensorProduct(A, B) {
                const m = A.length;
                const n = B.length;
                const result = Array(m * n).fill(null).map(() => 
                    Array(m * n).fill(null).map(() => new Complex(0))
                );

                for (let i = 0; i < m; i++) {
                    for (let j = 0; j < m; j++) {
                        for (let k = 0; k < n; k++) {
                            for (let l = 0; l < n; l++) {
                                result[i * n + k][j * n + l] = Complex.multiply(A[i][j], B[k][l]);
                            }
                        }
                    }
                }
                return result;
            }

            static calculateCHSH(rho) {
                // Define measurement operators
                const Z = Gates.Z();
                const X = Gates.X();
                
                // A = σ_z, A' = σ_x
                const A = Z;
                const Ap = X;
                
                // B = (σ_z + σ_x)/√2
                const B = this.createMeasurementOperator(Math.PI/4);
                
                // B' = (σ_z - σ_x)/√2
                const Bp = this.createMeasurementOperator(-Math.PI/4);

                const eAB = this.calculateCorrelation(rho, A, B);
                const eABp = this.calculateCorrelation(rho, A, Bp);
                const eApB = this.calculateCorrelation(rho, Ap, B);
                const eApBp = this.calculateCorrelation(rho, Ap, Bp);

                const S = eAB + eABp + eApB - eApBp;

                return { S, eAB, eABp, eApB, eApBp };
            }

            static createMeasurementOperator(theta) {
                const c = Math.cos(theta);
                const s = Math.sin(theta);
                return [
                    [new Complex(c), new Complex(s)],
                    [new Complex(s), new Complex(-c)]
                ];
            }
        }

        // Global state
        let quantumState = new QuantumState(2);
        let blochSphere = null;
        let circuit = [];
        let currentStep = 0;
        let noiseParams = {
            dephasing: 0,
            depolarizing: 0,
            amplitude: 0
        };
        let mitigationEnabled = {
            readout: false,
            zne: false
        };

        // Initialize Bloch sphere
        window.addEventListener('load', () => {
            blochSphere = new BlochSphere('blochCanvas');
            updateDisplay();
            setupEventListeners();
        });

        // Event listeners
        function setupEventListeners() {
            // Gate dragging
            document.querySelectorAll('.gate').forEach(gate => {
                gate.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('gate', e.target.dataset.gate);
                });
            });

            // Circuit tracks
            document.querySelectorAll('.qubit-track').forEach(track => {
                track.addEventListener('dragover', (e) => {
                    e.preventDefault();
                });

                track.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const gateType = e.dataTransfer.getData('gate');
                    const qubit = parseInt(track.dataset.qubit);
                    addGateToCircuit(gateType, qubit, e.offsetX);
                });
            });

            // Noise sliders
            document.getElementById('dephasingSlider').addEventListener('input', (e) => {
                noiseParams.dephasing = parseFloat(e.target.value);
                document.getElementById('dephasingValue').textContent = noiseParams.dephasing.toFixed(2);
                simulateCircuit();
            });

            document.getElementById('depolarizingSlider').addEventListener('input', (e) => {
                noiseParams.depolarizing = parseFloat(e.target.value);
                document.getElementById('depolarizingValue').textContent = noiseParams.depolarizing.toFixed(2);
                simulateCircuit();
            });

            document.getElementById('amplitudeSlider').addEventListener('input', (e) => {
                noiseParams.amplitude = parseFloat(e.target.value);
                document.getElementById('amplitudeValue').textContent = noiseParams.amplitude.toFixed(2);
                simulateCircuit();
            });

            // Timeline scrubber
            document.getElementById('timelineSlider').addEventListener('input', (e) => {
                currentStep = parseInt(e.target.value);
                simulateCircuit();
            });

            // Make gates draggable
            document.querySelectorAll('.gate').forEach(gate => {
                gate.draggable = true;
            });
        }

        function addGateToCircuit(gateType, qubit, xPosition) {
            const track = document.querySelector(`.qubit-track[data-qubit="${qubit}"]`);
            const gateElement = document.createElement('div');
            gateElement.className = 'placed-gate';
            gateElement.textContent = gateType;
            gateElement.style.left = `${xPosition - 30}px`;
            gateElement.dataset.gate = gateType;
            gateElement.dataset.qubit = qubit;
            gateElement.dataset.step = circuit.length;
            
            track.appendChild(gateElement);
            
            circuit.push({
                type: gateType,
                qubit: qubit,
                position: xPosition
            });

            // Update timeline max
            document.getElementById('timelineSlider').max = circuit.length;
            
            simulateCircuit();
        }

        function clearCircuit() {
            circuit = [];
            document.querySelectorAll('.placed-gate').forEach(gate => gate.remove());
            quantumState = new QuantumState(2);
            currentStep = 0;
            document.getElementById('timelineSlider').value = 0;
            document.getElementById('timelineSlider').max = 10;
            if (blochSphere) blochSphere.clearTrail();
            updateDisplay();
        }

        function simulateCircuit() {
            quantumState = new QuantumState(2);
            
            for (let i = 0; i <= currentStep && i < circuit.length; i++) {
                const gate = circuit[i];
                applyGate(gate);
                applyNoise();
            }
            
            updateDisplay();
        }

        function applyGate(gate) {
            let matrix;
            switch(gate.type) {
                case 'H': matrix = Gates.H(); break;
                case 'X': matrix = Gates.X(); break;
                case 'Y': matrix = Gates.Y(); break;
                case 'Z': matrix = Gates.Z(); break;
                case 'S': matrix = Gates.S(); break;
                case 'T': matrix = Gates.T(); break;
                case 'Rx': matrix = Gates.Rx(); break;
                case 'Ry': matrix = Gates.Ry(); break;
                case 'Rz': matrix = Gates.Rz(); break;
                case 'CNOT': 
                    matrix = Gates.CNOT();
                    quantumState.applyUnitary(matrix, [0, 1]);
                    return;
                default: return;
            }
            
            // For single-qubit gates, need to extend to full Hilbert space
            if (gate.qubit === 0) {
                matrix = CHSHCalculator.tensorProduct(matrix, Gates.I());
            } else {
                matrix = CHSHCalculator.tensorProduct(Gates.I(), matrix);
            }
            quantumState.applyUnitary(matrix, [gate.qubit]);
        }

        function applyNoise() {
            // Apply noise channels if enabled
            if (noiseParams.dephasing > 0) {
                const kraus = NoiseChannels.dephasing(noiseParams.dephasing);
                applyNoiseToQubit(kraus, 0);
            }
            
            if (noiseParams.depolarizing > 0) {
                const kraus = NoiseChannels.depolarizing(noiseParams.depolarizing);
                applyNoiseToQubit(kraus, 0);
            }
            
            if (noiseParams.amplitude > 0) {
                const kraus = NoiseChannels.amplitudeDamping(noiseParams.amplitude);
                applyNoiseToQubit(kraus, 0);
            }
        }

        function applyNoiseToQubit(krausOps, qubit) {
            // Extend Kraus operators to full Hilbert space
            const extendedKraus = krausOps.map(E => {
                if (qubit === 0) {
                    return CHSHCalculator.tensorProduct(E, Gates.I());
                } else {
                    return CHSHCalculator.tensorProduct(Gates.I(), E);
                }
            });
            quantumState.applyKrausOperators(extendedKraus);
        }

        function createBellState() {
            clearCircuit();
            addGateToCircuit('H', 0, 50);
            addGateToCircuit('CNOT', 0, 150);
            currentStep = 1;
            document.getElementById('timelineSlider').value = 1;
            simulateCircuit();
        }

        function updateDisplay() {
            // Get single-qubit reduced density matrix for qubit 0
            const rho = quantumState.densityMatrix;
            const rho0 = [
                [rho[0][0], rho[0][1]],
                [rho[1][0], rho[1][1]]
            ];
            
            // Create temporary single-qubit state for Bloch vector
            const singleQubitState = new QuantumState(1);
            singleQubitState.densityMatrix = rho0;
            
            const [x, y, z] = singleQubitState.getBlochVector();
            
            // Update Bloch sphere
            if (blochSphere) {
                blochSphere.updateStateVector(x, y, z);
            }
            
            // Update expectation values
            document.getElementById('expectX').textContent = x.toFixed(2);
            document.getElementById('expectY').textContent = y.toFixed(2);
            document.getElementById('expectZ').textContent = z.toFixed(2);
            
            // Update purity
            const purity = quantumState.purity();
            document.getElementById('purity').textContent = purity.toFixed(3);
            
            // Calculate and update CHSH
            const chsh = CHSHCalculator.calculateCHSH(quantumState.densityMatrix);
            document.getElementById('chshValue').textContent = chsh.S.toFixed(3);
            document.getElementById('chshValue').className = 
                chsh.S > 2 ? 'chsh-value chsh-quantum' : 'chsh-value chsh-classical';
            
            document.getElementById('eAB').textContent = chsh.eAB.toFixed(2);
            document.getElementById('eABp').textContent = chsh.eABp.toFixed(2);
            document.getElementById('eApB').textContent = chsh.eApB.toFixed(2);
            document.getElementById('eApBp').textContent = chsh.eApBp.toFixed(2);
            
            // Update fidelity metrics
            updateFidelityMetrics();
        }

        function updateFidelityMetrics() {
            // Calculate raw fidelity (simplified - comparing to ideal Bell state if circuit matches)
            let rawFidelity = quantumState.purity();
            
            // Apply mitigation if enabled
            let mitigatedFidelity = rawFidelity;
            
            if (mitigationEnabled.readout) {
                // Simple readout error mitigation simulation
                mitigatedFidelity = Math.min(1, rawFidelity * 1.1);
            }
            
            if (mitigationEnabled.zne) {
                // Zero-noise extrapolation simulation
                const improvement = (1 - rawFidelity) * 0.3;
                mitigatedFidelity = Math.min(1, mitigatedFidelity + improvement);
            }
            
            document.getElementById('rawFidelity').textContent = rawFidelity.toFixed(3);
            document.getElementById('mitigatedFidelity').textContent = mitigatedFidelity.toFixed(3);
        }

        function toggleReadoutCalibration() {
            mitigationEnabled.readout = !mitigationEnabled.readout;
            document.getElementById('readoutCalib').classList.toggle('active');
            updateDisplay();
        }

        function toggleZNE() {
            mitigationEnabled.zne = !mitigationEnabled.zne;
            document.getElementById('zneButton').classList.toggle('active');
            updateDisplay();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (blochSphere) {
                blochSphere.resize();
            }
        });
    </script>
</body>
</html>
